### 1.vue路由如何切换路由模式？（两种模式 hash ）

Vue中常用两种路由模式，分别为hash和history两种，其中hash特点在于它的URL中有一个#符号URL地址比较长可以刷新
而history模式与之相反 它的URL地址比较短切不可以刷新。可以使用mode:'路由模式' 进行切换

### 2.Vue2.0有哪些路由守卫？（路由独享守卫 、全局路由守卫、组件独享守卫）

全局路由守卫：beforEach 路由前置守卫 afterEach路由后置守卫
路由独享守卫：beforRouterEach 路由进入  beforRouterUpdata 路由更新 beforRouterLeave路由离开
组件独享守卫：beforEnter 路由进入之前

### 3.什么是微任务，什么是宏任务？

宏任务：根据JS代码执行顺序当执行遇到异步操作时 会将异步操作放到异步池中随后接着执行同步操作，其中异步池里的任务就叫做宏任务
微任务：异步操作中的方法或者回调，例如：promise.then.cath.all 等

### 4.什么是线程，什么是进程？

进程是资源分配的基本单位
线程是cpu调度和分派的基本单位，一个进程中可以存在多个线程任务，并且至少有一个线程，Javascript就属于单线程
JS可以使用new Worker得到一个文件路径然后在新线程中使用postMessage()方法实现多线程

### 5.Jsonp是不是ajax请求?（不是）

JsonP 不是ajax请求 Jsonp是通过script的src属性不受同源策略的影响进而实现解决跨域问题。是前端解决跨域问题中的一种

### 6.http的状态码(10条）？

100继续   200 链接成功  203非官方信息  204无内容  301请求文档在别的地方  307临时重定向  403禁止 404 文件丢失  503服务器维护  504 网关超时 

### 7.三次握手四次挥手？

三次握手：①客户端向服务端发送数据包②服务端接收到后向客户端发送数据包③客户端接收到服务端的数据后，在向服务端发送数据包
四次挥手：①客户端向服务端发出断开链接的请求②服务端接收到断开请求③数服务端告诉客户端可以断开链接④客户端断开链接

### 8.长连接和短连接？

长链接：发送一次请求，一直处于数据通信状态，直到主动断开链接 例如token就是长连接
短链接:发送一次请求，拿到数据后就断开链接

### 9.什么是事件轮询？什么是长轮询？什么是短轮询？

事件轮询：所有任务都在主线程上执行，形成一个执行栈进行轮回执行，主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里，执行栈将所有同步任务执行完毕，执行微任务队列，之后再执行宏任务队列。
长轮询：客户端发起请求，如果服务端的数据没有发生变更，那么就hold住请求，直到服务端的数据发生了变更，或者达到了一定的时间就会返回
短轮询：最简单的方式就是不断地发http请求，接收到请求之后，实时返回结果。

### 10.TCP和UDP的区别？

TCP：是一种可靠的传输方式，传输速度相对较慢，只能一对一进行连接
UPD:  是一种无连接且不可靠的传输方式，传输速度快，可以一对多进行连接

### 11、对 this 的四种指向, 三种改变 this 的方式 ?

1.任何情况下直接在script中写入的this都是window。 

2.函数中的this 非严格模式：this指向window， 严格模式时：this指向undefined。 

3.箭头函数的this 

this都指向箭头函数外上下文环境的this指向 

4.对象中this 

对象属性的this 指向对象外上下文环境的this 

对象方法(普通函数)中的this，指向当前对象(谁执行该方法，this就指向谁) 

5.回调函数的this指向 

1)、 setTimeout，setInterval回调函数不管是否是严格模式都会指向window。 

2)、通过在函数内执行当前回调函数 非严格模式：this指向window， 严格模式时：this指 

向undefined。 

3）递归函数中的this 非严格模式：this指向window， 严格模式时：this指向undefined。 

4) 使用arguments **0**执行函数时 this指向arguments。 

5）事件中的回调函数,this指向事件侦听的对象(e.currentTarget); 

6、call，apply，bind方法执行时this的指向 

如果call,apply,bind传参时，第一个参数传入的不是null或者undefined，传入什么this指向什么 

如果第一个参数传入的是null或者undefined ,非严格模式下指向window 

7、在ES6的类中this的指向 

构造函数中的this指向实例当前类所产生的新的实例对象 

类中实例化方法中this指向谁执行该方法，this指向谁 

类中静态方法中this执行该类或者该类的构造函数 

类中实例化箭头方法，this仍然指向当前类实例化的实例对象 

8、ES5的原型对象中this的指向 

在原型的方法中，this指向实例化当前构造函数的实例化对象（谁执行该方法，this指向谁）; 

三种改变this指向的方式 

函数名.call（this,....）this写谁就指谁。 

函数名.apply(this,[参数1，参数2，...]) this写谁就指谁。 

函数名. bind (this,1,2,3) this写谁就指谁。

### 12、输入 url 到打开页面 都做了什么事情 ? 

输入URL 

访问hosts解析，如果没有解析访问DNS解析 

TCP握手 

HTTP请求 

HTTP响应返回数据 

浏览器解析并渲染页面 

### 13、解释一下原型和原型链 ? 

原型：原型就是一个为对象实例定义了一些公共属性和公共方法的对象模板。

原型链 ：对象之间的继承关系通过构造函数的prototype指向父类对象，直到指向Object对象为止形成的指向链条。 通俗讲： 原型链是原型对象创建过程的历史记录。 

注：在javascript中，所有的对象都拥有一个__proto__属性指向该对象的原型（prototype) 。

### 14、深浅拷贝，以及使用的五种方式

1.浅拷贝：拷贝引用类型时，通过赋值的方式进行拷贝，赋值的方式只会把对象的表层赋值给一个新的对象，两个对象共享同一个地址，一个改变另一个会被影响随之改变。
2.深拷贝：拷贝引用类型时，重新开辟一个新的空间，存放数据，两个对象之间不会相互影响。
3.浅监听：引用数据类型的监听
(浅度监听)，是监听引用地址有没有变化。
4.深监听：引用数据类型深度监听，内部属性发生变化时，深监听能监听到。

实现的方式：1.递归实现 2.展开运算符 ... 实现 3.for...in 循环实现 4. 通过JSON.stringfy和JSON.parse实现 5.通过Object.assign实现

### 15、数组的变异方法和非变异方法，

在进行数组操作时，返回值是一个数组的话 该数组方法就是一个非变异方法，例如：filter(),map(),slice(),some(),forEach(),reduce () ,
与之相反，返回值是一个数字的话，该方法为变异方法，例如：push()，shift() ，unshift()，splice() ，sort() ，reverse()

### 16、ES6新特性

1.模板字符串 2.箭头函数 3.展开运算符 4.promise对象 5.数据结构map 6.async、await 7.声明命令let、const 8.symbol 9.解构 10.module模块化

### 17、前端性能优化的方式有哪些？

1、尽量减少 HTTP 请求，减少不必要的Cookie。

2、使用浏览器缓存。

3、使用压缩组件、压缩图片，图片预加载。

4、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

5、将脚本放在底部，将样式文件放在页面顶部。

6、使用外部的JS和CSS。

7、精简代码。打包公共代码，动态导入和按需加载。

8、当需要设置的样式很多时设置className而不是直接操作style。

9、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

10、避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。

### 18、防抖和节流

节流：指为了防止事件被频繁触发，设置定时器,达到一种一段事件内只触发一次的效果,在 当前事件内不会再次触			发,当前事件结束以后,再次触发才有效.
防抖：是指当一个事件触发的时候, 为防止频繁触发事件, 设置定时器,以达到一种 频繁触发期间不处理, 只有当最			后 一次连续触发结束以后才处理

### 19、前端主流的库（lodash）

### 20、vue2和vue3的区别

1.vue2采用的是面向对象编程，vue3采用函数式编程
2.vue3修改了细腻dom算法，只针对变化的层进行diff，而vue2是对所有的dom进行diff
3.数据双向绑定 ：vue2使用的是Object.defineProperty，vue3使用的是proxy
4.创建vue实例：vue2：new Vue({})
vue3: vue.createApp({})
5.vue3没有this

### 21、说一下对vue中render函数的理解

render()函数用来渲染模板 jsx文件等等 Ejs文件

### 22、vue.use的作用

（挂载插件）(声明全局组件）

### 23、v-mode的原理

v-model只不过是一个语法糖而已,真正的实现靠的还是v-bind:绑定响应式数据触发oninput 事件并传递数据

### 24、实现继承方式

1、原型链继承
2、借用构造函数来继承
3、构造函数+原型链 组合继承
4、实例继承：为父类实例添加新特性，作为子类实例返回 ； 拷贝继承 寄生组合式继承
5、原型式继承
6、寄生式继承
7、class+extends继承

### 25、什么是变量提升，如何阻止变量提升

函数和var声明的变量会被提升 会将当前作用域的所有变量的声明，提升到程序的顶部可以使用let const阻止变量提升

![1660291433395](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1660291433395.png)

### 26、跨域怎么产生的，怎么解决跨域问题

端口，协议，域名三者相同称为同源，三者有一项不同就称为跨域。jsonp-原理:引入资源不受同源策略的限制.动态创建script标签，src指向跨域文件,该跨域文件的响应内容，就会变成script标签的内容
反向代理-原理:当前端请求数据的时候，把前端地址代理成后端地址
cors-原理:允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制

### 27、解释什么是token，

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌

### 28、什么强缓存，什么是弱缓存，什么是协商缓存

强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取。缓存 由服务器的响应头里 cache-control 和 expires 两个字段决定 

协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求"询问"该请求的文件缓存在ben'd与服 务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取。协商缓存由 last-modified 和 etag两个字段决定

### 29、cookie, Storage,session 的区别 ?

### 30、Vue.nextTick 、vue.extends

NextTick在DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的DOM将异步变为同步

使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数

vue.nextick(将回调延迟到下一次DOM更新之前),vue.extend(扩展生成一个新的子类)