### 1.vue路由的切换模式？

hash模式和history模式

hash:切换路由，只改变#后面的值，就可以切换路由，不重新刷新页面，浏览器也会记录，左右箭头可以进行前进和后退操作。

history:  每次刷新会重新向后端请求整个网址，也就是重新请求服务器。如果后端没有及时响应，就会报错404！。url地址要和后端保持一致。

### 2.vue2.0有哪些路由守卫？

第一种全局守卫:beforeEach和afterEach,第二种组件内守卫beforeRouterEnter、beforeRouteUpdate、beforeRouteLeave ,组件独享守卫beforeEnter

### 3.什么是微任务？什么是宏任务？

在js当中异步任务又进行了划分为:宏任务(异步ajax请求、setTimeout 、setInterval、文件操作),微任务(Promise.then , .catch 和 .finally\nextTick)

### 4.说一下什么是线程什么是进程？

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。

### 5.jsonp是不是一个ajax请求？

不是,jsonp的核心是动态添加script标签调用服务器提供的js脚本

### 6.HTTP状态码有哪些？(10条)

100：接受的请求正在处理，信息类状态码

200:服务器已成功处理了请求。

300：301，永久性重定向，表示资源已被分配了新的 URL
302，临时性重定向，表示资源临时被分配了新的 URL
303，表示资源存在另一个URL，用GET方法获取资源
304，(未修改)自从上次请求后，请求网页未修改过。服务器返回此响应时，不会返回网页内容

400:(错误请求)服务器不理解请求的语法
401表示发送的请求需要有通过HTTP认证的认证信息
403(禁止)服务器拒绝请求
404(未找到)服务器找不到请求网页

500:(服务器内部错误)服务器遇到错误，无法完成请求
503，表示服务器处于停机维护或超负载，无法处理请求

### 7.三次握手和四次挥手?

三次握手：①客户端向服务端发送数据包②服务端接收到后向客户端发送数据包③客户端接收到服务端的数据后，在向服务端发送数据包
四次挥手：①客户端向服务端发出断开链接的请求②服务端接收到断开请求③数服务端告诉客户端可以断开链接④客户端断开链接

### 8.什么是长链接和短链接?

长链接：发送一次请求，一直处于数据通信状态，直到主动断开链接 例如token就是长连接
短链接:发送一次请求，拿到数据后就断开链接

### 9.什么是事件轮询(长轮询和短轮询)?

事件轮询：所有任务都在主线程上执行，形成一个执行栈进行轮回执行，主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里，执行栈将所有同步任务执行完毕，执行微任务队列，之后再执行宏任务队列。
长轮询：客户端发起请求，如果服务端的数据没有发生变更，那么就hold住请求，直到服务端的数据发生了变更，或者达到了一定的时间就会返回
短轮询：最简单的方式就是不断地发http请求，接收到请求之后，实时返回结果。

### 10.TCP和UDP区别

TCP：是一种可靠的传输方式，传输速度相对较慢，只能一对一进行连接
UDP:  是一种无连接且不可靠的传输方式，传输速度快，可以一对多进行连接

### 11.说一下this的几种指向问题?

this出现在全局函数中,永远指向window。

this出现在严格模式中 永远不会指向window函数中使用es5的严格模式‘use strict’，this为undefined

当某个函数为对象的一个属性时，在这个函数内部this指向这个对象

this出现在构造函数中，指向构造函数新创建的对象

当一个元素被绑定事件处理函数时，this指向被点击的这个元素

this出现在箭头函数中时，this和父级作用域的this指向相同

### 12.在地址栏输入url地址显示页面做了哪些事?

dns解析、tcp连接、发起http请求、处理请求、浏览器渲染、tcp断开连接

### 13.原型和原型链的区别?

原型:每个函数都有prototype属性，该属性指向原型对象；使用原型对象的好处是所有对象实例共享它所包含的属性和方法。

原型链:每个对象都拥有一个原型对象，通过__proto__指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null。

### 14.什么是深拷贝什么是浅拷贝?(5种)

**深拷贝：**拷贝的是对象或者[数组](https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020)内部数据的实体，重新开辟了内存空间存储数据；
**浅拷贝：**拷贝的是引用类型的指针，副本和原数组或对象指向同一个内存；

深拷贝的五种方法:JSON.stringify()、递归、jQuery的extend方法实现深拷贝、函数库lodash的_.cloneDeep方法、Object.assign(obj1, obj2)、扩展运算符、concat数组方法

### 15.组数有哪些变异方法和非变方法?

push() pop() shift() unshift() splice()  sort()  reverse() 

非变异:

### 16.ES6新特性？

var  let  const、扩展运算符、数组和对象方法新增、set、map、promise、Generator、proxy、module Decorator

### 17.项目中前端性能优化的方式?

减少http请求次数、图片优化---->雪碧图、使用字体图标、减少重定向、使用缓存，减少资源大小压缩文件、优化资源加载--->资源的加载位置和资源的加载时机

### 18.防抖节流?

节流：简单地说，就是限制一个动作在一段时间内只能执行一次

防抖：简单地说，就是 当一个动作连续触发，只执行最后一次。

### 19.有没有用过前端主流的库?lodash

### 20.vue2和vue3区别?

1.vue2采用的是面向对象编程，vue3采用函数式编程
2.vue3修改了细腻dom算法，只针对变化的层进行diff，而vue2是对所有的dom进行diff
3.数据双向绑定 ：vue2使用的是Object.defineProperty，vue3使用的是proxy
4.创建vue实例：vue2：new Vue({})
vue3: vue.createApp({})
5.vue3没有this

### 21.说一下render函数和h函数的理解?

### 22.vue.use有什么意义?（挂载插件）(声明全局组件）

### 23.v-model的原理?

v-model只不过是一个语法糖而已,真正的实现靠的还是v-bind:绑定响应式数据触发oninput 事件并传递数据

### 24.继承的方式有哪些?

1、原型链继承
2、借用构造函数来继承
3、构造函数+原型链 组合继承
4、实例继承：为父类实例添加新特性，作为子类实例返回 ； 拷贝继承 寄生组合式继承
5、原型式继承
6、寄生式继承
7、class+extends继承

### 25.什么是变量提升?如何阻止?

函数和var声明的变量会被提升 会将当前作用域的所有变量的声明，提升到程序的顶部可以使用let const阻止变量提升

### 26.跨域怎么产生的，该如何解决?

端口，协议，域名三者相同称为同源，三者有一项不同就称为跨域。jsonp-原理:引入资源不受同源策略的限制.动态创建script标签，src指向跨域文件,该跨域文件的响应内容，就会变成script标签的内容
反向代理-原理:当前端请求数据的时候，把前端地址代理成后端地址
cors-原理:允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制

### 27.解释什么是token？

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌

### 28.什么是强缓存、弱缓存和协商缓存?

强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取。缓存 由服务器的响应头里 cache-control 和 expires 两个字段决定 

协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求"询问"该请求的文件缓存在ben'd与服 务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取。协商缓存由 last-modified 和 etag两个字段决定

### 29.cookie、storage和seesion区别？



### 30.vue.$nextTick和vue.extends

​	nextTick:将回调函数延迟在下次dom更新数据后调用，当数据更新了，在dom中渲染后，自动调用该函数。

​	它是Vue构造器的扩展，调用`Vue.extend()`创建的是一个组件构造器，而不是一个具体的组件实例， extend就是一个构造器，就像原生js的构造函数，可以new N次，构造N个对象，但是不能重复使用

### 31.[VUE父子组件生命周期执行顺序 ￼](https://www.cnblogs.com/luhu123/p/16522839.html)

vue父子组件生命周期执行顺序

1.首先执行的是父组件的beforeCreate

2.执行的是父组件的created周期

3.执行的是父组件的beforeMount周期

4.执行的是子组件的beforeCreate周期

5.执行的是子组件的created周期

6.执行的是子组件的beforeMount周期

7.执行的是子组件的mounted周期

8.执行的是父组件的mounted周期

总结：

执行的先后顺序为 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 。

















































